## Kanban

Una metodologia de geston que utiliza tableros visuales y tarjetas para representar tareas y su progreso a traves de un flujo de trabajo, con el objetivo de optimizar la eficiencia y la productividad. Originado en el sistema de produccion "justo a tiempo" de toyota en la decada de 1950. Kanban se ha adaptado para diversos sectores, como el desrrollo de software y la gestion de conocimiento, para facilitar la mejora continua, la visualizacion del flujo de trabajo y la limitacion del trabajo en curso (WIP)

### Principios claves de Kanban

- Visualizar el trabajo: Se utiliza un tablero para mostrar las tareas y el estado
- Limitar el trabajo en curso (WIP): Evitar sobrecarga
- Gestionar el flujo: Identifica y elimina cuellos de botella
- Explicitar politicas de proceso: 
- Mejorar en colaboración: No se despide, se apoya.

Kanban se origino en la industria automotriz japonesa como un sistema de programación para la fabricación "justo a tiempo", basado en la demanda del cliente

Luego se adapto => Ing Davir Anderson aplicó los principios 

<img width="932" height="676" alt="image" src="https://github.com/user-attachments/assets/7b3ad533-b97f-487c-b2c8-56e8e773fcab" />

> [!IMPORTANT]
> Requerimiento funcional: Si se quita, deja de funcionar

> [!IMPORTANT]
> Requerimiento no funcional: Si se quita, sigue funcionando

> [!TIP]
> Kanban y Scrum se pueden trabajar en conjunto de manera hibrida

## Extreme Programming (XP)
Un conjunto de prácticas para el desarrollo de software de alta calidad. Esta herramienta es muy útil sobre todo para startups o empresas que están en proceso de consolidación, puesto que su principal objetivo es ayudar en las relaciones entre los empleados y clientes. La clave del éxito del Extreme Programming XP es potenciar las relaciones personales, a través, del trabajo en equipo, fomentando la comunicación y eliminando los tiempos muertos.

Sus principales fases son:

- Planificación del proyecto con el cliente.
- Diseño del proyecto.
- Codificación, donde los programadores trabajan en pareja para obtener resultados más eficientes y de calidad.
- Pruebas para comprobar que funcionan los códigos que se van implementando.

La calidad se mide en el resultado, cuando el usuario dice, yo quiero esto.

### Valores fundamentales de la programación extrema

***Comunicación***
Fomenta la comunicación constante y cara a cara entre los miembros del equipo y con el cliente para evitar malentendidos y asegurar la comprensión. 

***Simplicidad***
Busca la solución más sencilla y eficiente posible, evitando la complejidad innecesaria y la sobre-documentación. 

***Retroalimentación***
Se enfoca en recibir y dar feedback continuo a través de revisiones de código, pruebas unitarias y la interacción con el cliente para mejorar el producto. 

***Coraje***
Implica la voluntad de tomar decisiones difíciles, como realizar cambios en el código o incluso empezar de nuevo, si es necesario para mejorar el proyecto. 

***Respeto***
Establece un entorno de trabajo colaborativo donde todos los miembros se respetan mutuamente, se apoyan y se sienten comprometidos con el éxito del proyecto. 

### Prácticas clave

***Programación en parejas***
Dos programadores trabajan juntos en el mismo código, lo que mejora la calidad y la eficiencia. 

***Desarrollo basado en pruebas***
Se escriben pruebas unitarias y de aceptación antes de escribir el código de producción.
 
***Integración continua***
El código se integra y prueba frecuentemente para detectar y corregir errores rápidamente.
 
***Planificación de lanzamientos (Release Planning)***
Se realizan lanzamientos frecuentes de software funcional en ciclos cortos (sprints) para entregar valor al cliente. 

***Refactorización***
Se mejora continuamente la estructura del código existente para facilitar el mantenimiento y la adición de nuevas funcionalidades. 

***Simplicidad del diseño***
Se crea un diseño simple y se evoluciona a medida que se comprende mejor el sistema y el problema. 

***Historias de usuario***
Pequeñas descripciones de las características deseadas desde la perspectiva del cliente. 

Cuando se construye un software la etapa de "enamoramiento" se termina cuando ocurre una nueva necesidad. => Refactorización. Lo que hoy fabrico es mi obsolecencia del mañana.
Ej: Lo que yo cocino hoy, despues ya no es fresca. Luego se echa a perder. => Con el software pasa lo mismo.

Ej: La gente con auto, lo cuida, le echa laca, etc. Si pasa un auto mejor, lo miras te "enamoras" y el auto que uno tiene pasa a ser una herramienta no más.

## Ciclo de vida de la programación extrema

<img width="1060" height="505" alt="image" src="https://github.com/user-attachments/assets/5842cf2e-2ac3-4984-8220-f7fd34f999b1" />

Cuando la prueba sale insatisfactoria, o corrijo o empiezo de nuevo (la tarea) => Ese es el problema que tiene la programación extrema.

## Origen de SCRUM

Scrum pasó de ser un método utilizado por un número de entusiastas en Easel Corporation en 1993, a uno de los marcos para el desarrollo de software más populares y conocidos del mundo. La continua expansión de su implementación, globalmente, es un testimonio que confirma a esta metodología, como acorde a la promesa implícita en sus principios y postulados. Aunque a menudo se dice que Scrum no es una bala de plata, esta metodología puede ser como un misil en busca de calor cuando apunta en la dirección correcta. Al centrarse en la construcción de comunidades de stakeholders, fomentando una vida mejor para los desarrolladores, así como la entrega del valor del negocio a los clientes, puede liberar la creatividad y el espíritu de equipo de los profesionales, haciendo del mundo un lugar mejor para vivir y trabajar.

“Scrum surgió a partir de una estructura de desarrollo en bruto, iterativa e incremental, que dio paso a un marco estructurado, refinado y directo para el desarrollo de productos complejos” (Sutherland, 2010, p.5).

> [!NOTE]
> Stakeholders: Grupo de personas ***Interesados*** o clientes

Ejemplo Mejora de calidad de vida: Edificio construcción en 4 meses. Pero si lo terminan en 3, tienen 1 mes pagado libre y un bono. 

## Ciclo general de SCRUM

<img width="1011" height="472" alt="image" src="https://github.com/user-attachments/assets/b5139da4-ba60-4f0e-ad25-ffa4f722212d" />

El problema de lo secuencial es que cuando termino, tengo que probar. Si el proceso de prueba no funciona, tengo que partir de nuevo de 0 o arreglarlo y luego recien comienza la segunda tarea.

En SCRUM la tarea parte, pero aun no termina, y luego comienza la segunda tarea. Si no funciona y tiene algun problema, se soluciona, pero el segundo equipo sigue trabajando.

Caso 3: Un inicio, luego parte el 2, 3, 4 pero se asemejan en que el punto final.

> [!IMPORTANT]
> Son procesos iterativos, porque no dependen del otro

- Requerimiento
- Diseño
- Código
- Prueba

## Comparación del ciclo de vida de Scrum y los ciclos visualizados por Takeuchi y Nonaka

<img width="1034" height="327" alt="image" src="https://github.com/user-attachments/assets/6f921104-48e7-4d63-ad96-d8809718814f" />

## Ciclo de vida según SCRUM

<img width="754" height="671" alt="image" src="https://github.com/user-attachments/assets/c40603c1-2e1e-42d1-a38e-7229e7ac38eb" />

> [!NOTE]
> En Sprint Retropective tiene que estar el cliente

### Las actividades principales de Scrum son

- Al inicio del proyecto se establece su factibilidad, visión y valor del negocio.

- Después se listan los requerimientos creando el Product Backlog.

- Al principio de cada iteración se seleccionan aquellos requerimientos que agregan mayor valor. **(Mayor valor = Mayor prioridad)**

- El equipo los analiza y define tareas para desarrollar cada uno de ellos, esas tareas conforman el Sprint y se registran en el Sprint Backlog.

- Al final de cada Sprint hay nueva funcionalidad para probar, la cual es presentada para revisión por parte de los usuarios y clientes.

- Diariamente se revisa el estado de las tareas para detectar y remover obstáculos. (Daily meeting)

### Product Backlog (PB)

Un proyecto Scrum es guiado por una visión de producto elaborado por un dueño de ese producto (Product Owner). Esta visión de producto se convierte en una lista priorizada de lo que se requiere llamada Product Backlog, donde las necesidades de usuario están clasificadas por orden de valor para el cliente o negocio. Los ítems de mayor valor están en la parte superior de la lista.

Cada ítem de la lista contiene también la información relacionada con la planificación de su implementación y el número de Sprint donde se implementará.

El PB evoluciona durante la vida útil del proyecto, y las necesidades se agregan, cambian o eliminan, continuamente. Cada vez que ocurre un cambio en el PB, la lista se vuelve a priorizar. Así el equipo del proyecto tiene siempre la visión sobre los próximos requerimientos a implementar.

> [!NOTE]
> Priorizar => Para asignarle valor utilizamos el método Moscú (Moscow)

#### Ejemplo de Product Backlog (PB)

<img width="1231" height="515" alt="image" src="https://github.com/user-attachments/assets/2be3d5f5-b7d6-4c0a-b353-c1785834fa96" />

***Estimación original:*** Estimación en tiempo, puede ser días o horas. 

> [!WARNING]
> Si ocupamos la estimación en horas hay que tener cuidado.

Ejemplo planificación de un asado:
¿Cuanto me demoro?
24 horas => En Chile se trabajan 40 horas semanales => 8 horas diarias => 24 horas = 3 días.

***Factor de complejidad***: Aquí se asigna un tiempo adicional en %. 

Por ejemplo: Paseo a la nieve => Cambio de bus, gente que no ha pagado la cuota, etc.

***Estimaciones***: | 8 horas | 8 horas | 8 horas, etc (más de 8 horas no se puede, menos si)

# Ejercicio

<img width="863" height="794" alt="image" src="https://github.com/user-attachments/assets/f9a23e1b-93ee-4eb7-9e2c-57cb503395bf" />

1 y 3 son funcionales

2 y 4

# Requerimientos Funcionales
Son enunciados acerca de servicios que el sistema debe proveer, de cómo debería reaccionar el sistema a entradas particulares y de cómo debería comportarse el sistema en situaciones específicas.


# Requerimientos No Funcionales
Son limitaciones sobre servicios o funciones que ofrece el sistema. Incluyen restricciones tanto de temporización y del proceso de desarrollo.



## Comparación de RF y RNF según tu caso
#	Requerimiento	Tipo	Razón
1	Se deberán poder crear productos en el inventario (libros, revistas, enciclopedias) con editorial, autores y descripción.	Funcional	Define una función directa del sistema: registrar productos con sus datos.
2	Se deberán gestionar las bodegas existentes, identificándolas de forma única.	No funcional	No describe una acción del usuario, sino una característica obligatoria (cada bodega debe estar identificada de manera única).
3	Se deberá poder agregar o sacar productos de las bodegas, generando un documento de movimiento (origen, destino, productos, cantidades).	Funcional	Es una operación concreta del sistema: trasladar productos entre bodegas con registro.
4	Se deberá proveer una previsualización del documento de movimiento de productos antes de confirmar.	No funcional	Es una condición de usabilidad: ver el documento antes de finalizar la acción, no es una nueva función de negocio.

👉 Una forma de recordarlo:

Funcional = verbo de acción (crear, agregar, eliminar, mover).

No funcional = cualidad/condición (único, rápido, seguro, visible, escalable).

# Método Moscow

El método MoSCoW es una técnica poderosa para el seguimiento de las prioridades, que se categorizan y ubican en un modelo de matriz. Los administradores de proyecto, desarrolladores de producto y analistas de negocios usan la matriz para alinear a sus equipos cuando trabajan en un conjunto de entregas de proyecto.

MoSCoW es un acrónimo que significa "debe tener, debería tener, podría tener y no tendrá". Estas cuatro categorías prioritarias constituyen los cuatro segmentos de la matriz. Los elementos en "debe tener" son necesarios para la entrega; los de "debería tener" son importantes, pero no imprescindibles; los de "podría tener" son cosas que sería bueno tener (no son prioridades, pero el equipo puede trabajar en ellos si el tiempo y los recursos lo permiten) y los de "no tendrá" no encajan en el alcance del proyecto actual. Para usar MoSCoW, debes crear cuatro segmentos de categorías que muestren tus prioridades actuales y su estado (completo, en progreso o aún no iniciado).


<img width="934" height="295" alt="image" src="https://github.com/user-attachments/assets/9ba27ce9-1d6a-405e-8be8-15a27c9fc0ef" />

