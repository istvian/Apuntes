# Procedimientos PL/SQL con procedimientos almacenados (stored procedure sp) y Funciones almacenadas (stored function sf)

Subprogramas o bloque PL/SQl. Pueden ser llamados junto a parametros. Es posible declarar y definir un subprograma. Dentro de las partes encontramos una especificacion.

## SP y SF
Las funciones tienen que tener un return

# SP
Ejemplo:
<img width="1365" height="427" alt="image" src="https://github.com/user-attachments/assets/4143aa35-4dca-482e-aedc-c892a20868f2" />

>[!IMPORTANT]
> Para ver las salidas hay que ejecutar el set serveroutput on;


```sql
set serveroutput on;
```

```sql
create or replace procedure sp1
as
mensaje varchar2(7):='hoy es ';   /* tipo texto */

begin
dbms_output.put_line(mensaje||sysdate);
end;

```


Hacer eso se llama compilar

<img width="256" height="110" alt="image" src="https://github.com/user-attachments/assets/59c0bc74-d508-4fdf-90f5-ccad99976c62" />

Para ejecutar 

```sql
exec sp1
```

Salida:  
<img width="439" height="184" alt="image" src="https://github.com/user-attachments/assets/730392e9-6d22-4825-a9e7-c20c4c611646" />

Para ver procedimientos hay:


```sql
select object_name
from user_procedures
where object_type='PROCEDURE'

```


<img width="333" height="123" alt="image" src="https://github.com/user-attachments/assets/b7455b25-1041-4e1d-90d5-1ea406078bf0" />

Para eliminar un procedimiento:
```sql
drop procedure sp1
```

## Ejemplo 2:

Crearemos un sp (procedimiento almacenado) ejemplo2 que imprimirá una fecha y luego se creará un sp que imprimirá un mensaje y llamará  al procedimiento ejemplo2.

```sql
-- Crea un procedimiento
create or replace procedure sp2
as
fecha date:='12/6/2022';
monto number(6):=250000;

begin
dbms_output.put_line(fecha||'->'||monto);
end;

-- Lo ejecuta
exec sp2;

-- Crea un procedimiento que llama a SP2
create or replace procedure llamaSp2
as
mensaje varchar2(20):='Ventas del día:';

begin
dbms_output.put_line(mensaje);
sp2;
end;

-- Ejecuta 
exec llamasp2;

```

<img width="407" height="271" alt="image" src="https://github.com/user-attachments/assets/5a8d0717-15a8-443d-8e32-c7032ab5ed62" />

## EJEMPLO 3

```SQL

-- CARGAR SCRIPT
-- CREA TABLAS
create table vestuario(
codVest varchar2(5) not null primary key,
descripcion varchar2(20),
precio number(8),
stock number(3)
);

create table ventafinal(
numVenta number(8) not null primary key,
fecha date,
cantVendida number(3),
codigoVest varchar2(5) not null references vestuario
);

-- CREA SECUENCIA
create sequence sec_ven
start with 1;

-- INSERTA
insert into vestuario values('v2089','short',10000,35);
insert into vestuario values('v2097','polera',25000,50);
insert into vestuario values('v2102','pantalón',15000,40);
insert into vestuario values('v2155','camisa',20000,18);
insert into vestuario values('v2209','blusa',28000,40);
insert into ventafinal values(sec_ven.nextval,'11/11/2021',10,'v2097');
update vestuario set stock=stock-10 where codvest='v2097';
insert into ventafinal values(sec_ven.nextval,'17/11/2021',5,'v2089');
update vestuario set stock=stock-5 where codvest='v2089';
insert into ventafinal values(sec_ven.nextval,'26/11/2021',6,'v2097');
update vestuario set stock=stock-6 where codvest='v2097';
insert into ventafinal values(sec_ven.nextval,'27/11/2021',6,'v2155');
update vestuario set stock=stock-6 where codvest='v2155';
insert into ventafinal values(sec_ven.nextval,'29/11/2021',5, 'v2209');
update vestuario set stock=stock-5 where codvest='v2209';
insert into ventafinal values(sec_ven.nextval,'30/11/2021',15, 'v2097');
update vestuario set stock=stock-15 where codvest='v2097';

delete from vestuario where codvest='v2102';

select * from vestuario;

--CREA PROCEDIMIENTO SP3 QUE AUMENTA EN 50% EL PRECIO DE LAS CAMISAS
create or replace procedure sp3
as
 begin
  update vestuario set precio=precio*1.5
  where codvest ='v2155';
 end;

exec sp3;

select * from vestuario;

```
ANTES:  
<img width="541" height="211" alt="image" src="https://github.com/user-attachments/assets/be27f731-3933-4925-95ea-930dffa8e8b5" />
DESPUES:  
<img width="556" height="200" alt="image" src="https://github.com/user-attachments/assets/ff31755b-cf26-4eb2-9fc5-5d895e997e89" />

## EJEMPLO 4

```SQL
create or replace procedure sp4
as
 begin
-- INSERTA 6 PRODUCTOS A VENTA Y BAJA DE STOCK 6
  insert into ventafinal values(sec_ven.nextval,'2/12/2021',6,'v2097');
  update vestuario set stock=stock-6 where codvest='v2097';
 end;

-- SI COMPILAMOS Y EJECUTAMOS

EXEC SP4;
select * from ventafinal;
select * from vestuario;
-- Se ve reflejado en los selects
```

## EJEMPLO 5

```SQL
create or replace procedure sp_stock as
begin  
   dbms_output.put_line('Resultado');
   for vRow in (select codvest,descripcion,stock from vestuario) 
    loop   /* se mantiene imprimiendo */
         dbms_output.put_line(
	     'Del vestuario '||vRow.codvest||'-'||vRow.descripcion||'  quedan= '||vRow.stock);
    end loop;
end;

-- IMPRIME RESULTADO
-- HACE UN FOR
-- vRow es un nombre que uno quiera
-- Dentro del for usa un loop
-- Muestra los campos de la tabla

exec sp_stock;
```
<img width="356" height="169" alt="image" src="https://github.com/user-attachments/assets/a2929060-9833-473b-967e-a937fe352844" />

# Funciones Almacenadas (sf)

<img width="1315" height="466" alt="image" src="https://github.com/user-attachments/assets/2aa47fdf-da94-4fa3-8779-cc5ac6fc43ae" />

Las sf se almacenan en la base de datos como objetos de esquema.


Una función almacenada (sf) es un bloque PL/SQL que posee un nombre y que puede aceptar parámetros. Las sf al ser llamadas desarrollan acciones para calcular un valor, el cual retornan. 

> [!NOTE]
> Se ejecutan con un select al igual que los views

## Ejemplo 1: Retorna un texto en pantalla
```sql
Create or replace function mensaje
return varchar2
is
begin
     return 'Probando una función';
end;

SELECT MENSAJE FROM DUAL;

```

<img width="407" height="106" alt="image" src="https://github.com/user-attachments/assets/3d43625f-c019-4f5c-b94e-5ba7f7d7709a" />


PARA VER QUE SF TENEMOS EN LA BD:

```SQL
select object_name
from user_procedures
where object_type='FUNCTION';
```

PARA ELIMINAR:

```SQL
drop function mensaje;
```

## Ejemplo 2: Usaremos una función, para mostrar el promedio de precios de la tabla vestuarios


> [!TIP]
> Hay que definir en la entrada y salida el tipo de salida. Ej: Number o Varchar2

```sql
create or replace function sf_prom
return number
is 
avg_p  vestuario.precio%TYPE; -- Define una varible llamada avg_p y obtiene el tipo desde vestuario.precio con %TYPE

begin  
    select avg(precio) into avg_p from vestuario; -- into el resultado se lo pasa a una variable
    return avg_p; -- retorna avg_p
end;

select sf_prom from dual;

```

# Procedimientos almacenados (con parametros)

Existen las funciones con parametros, pero en el contenido de la asignatura no lo pide. Asi que se alineo con el contenido de la asignatura. Es lo mismo con las funciones.

## Ejemplo 1: Crearemos un procedimiento para mostrar el stock para aquel artículo con el código enviado como parámetro.

```sql
create or replace procedure mostrarstock (cod in varchar2) 
as  v_stock number;
begin
    select stock   into v_stock
    from vestuario
    where codvest = cod;
    dbms_output.put_line('El stock del vestuario ' || cod || ' es: ' || v_stock);
end;


exec mostrarstock('v2209'); -- Al llamar el procedimiento se mandó un código

```
<img width="393" height="105" alt="image" src="https://github.com/user-attachments/assets/2b4b1625-18a9-425b-aeb1-e674b9dbd080" />


## Ejemplo 2: Crearemos un procedimiento para actualizar el precio de todos los artículos de vestuario, indicando al ejecutar el porcentaje de aumento.


```sql
create or replace procedure cambiaprecio(valor number) -- Parametro
as
begin
    update vestuario set precio=precio*(1+(valor/100)); 
end;

exec cambiaprecio(5);
exec cambiaprecio(-8);

select * from vestuario;
```
## Ejemplo 3: Crearemos un procedimiento que recibirá el número de venta y un valor, con eso actualizará la cantidad vendida de ese número de venta si se ingresa un valor mayor a 0 o eliminará ese número de venta, si se ingresa un valor 0.

```
Se usará la condicionalidad: 
if <cond> then
	instrucciones;
else
	instrucciones;
end if;

```

```sql
-- Escribir y compilar este procedimiento

create or replace procedure cambiaventa(numv number,cant number)
as
begin
-- Si es mayor a 0 actualiza la cantidad del numv 
    if cant>0 then
        update ventafinal set cantvendida=cant where numventa=numv;
        dbms_output.put_line('Se modificó la cantidad vendida');
-- Si es igual o menor que 0 elimina la venta
    else
        delete from ventafinal where numventa=numv;
        dbms_output.put_line('Se eliminó la venta');
    end if;
end;

exec cambiaventa(2,0)
exec cambiaventa(3,8)

```

# Triggers o disparador
Un trigger, también llamado disparador o gatillador,  es un bloque de código que se ejecutará automáticamente cada vez que ocurra una operación definida, por ejemplo, al insertar un registro en una tabla, o al usar update o delete .


Lo que hace es automatizar tareas, lo dejas esperando a que ejecutes una acción y el trigger se ejecuta solo. Cuando uno le diga que se ejecute. Usa disco y memoria, consume recursos. Hay que tener cuidado con el consumo de recursos. Son una "maravilla".  


Sintaxis:

```
CREATE OR REPLACE TRIGGER nombre-del-trigger    [FOLLOWS nombre-otro-trigger]    [BEFORE/AFTER]    [INSERT/DELETE/UPDATE/UPDATE OF lista-columnas]    ON nombre-tabla    [REFERENCING [OLD AS nombre-antiguo][NEW AS nombre-nuevo]]    [FOR EACH ROW/FOR EACH STATEMENT]    [WHEN {condiciones}]      {Bloque estándar de sentencias PL/SQL... BEGIN, EXCEPTION}

```

## Ejemplo 1: Crearemos y compilaremos un trigger para la tabla vestuario, para que cada vez que se inserte un artículo se escriba en pantalla Se ha insertado en vestuario

```sql
Create or replace  trigger mensaje_ins
after insert on vestuario -- despues de insertar en la tabla vestuario
begin
	dbms_output.put_line('Se ha insertado en vestuario'); -- muestra un mensaje
end;

insert into vestuario values(22600,'parka',60000,20)

-- Para ver que triggers hay en la base de datos
select trigger_name from user_triggers;

-- Muestra el nombre del trigger màs el estado
select trigger_name, status from user_triggers;

-- Se puede dejar en pausa un trigger
alter trigger mensaje_ins disable;

insert into vestuario values(23800,'Calcetín',10000,40);
-- Este insert no muestra el mensaje ya que el trigger esta desactivado


-- Para habilitar nuevamente se ejecuta con enable
alter trigger mensaje_ins enable;

-- Si ejecutamos este insert, vuelve a aparecer el mensaje
insert into vestuario values(25800,'Camisa',20000,50);

-- Para eliminar un trigger
drop trigger mensaje_ins;

-- En la vida real no se eliminan tablas ni triggers, es muy raro hacer eso. Pero es importante saberlo

```

## Ejemplo 2: Crearemos un trigger para la tabla ventafinal, para que cada vez que se inserte una venta se rebaje, automáticamente, el stock en la tabla vestuario de ese artículo vendido.

El trigger cada vez que se inserte una venta, va a ejecutar un update.

> [!NOTE]
> El trigger es como un "asistente de trabajo", cuando yo haga "x" tu haz "y". Son muy usuarios

```sql
Create or replace trigger vendeyrebaja -- Crea el trigger que se llama vendeyrebaja
after insert on ventafinal --Despues de que yo inserte en ventafinal
for each row -- por cada fila que inserte

begin -- ejecuta esto
update vestuario set stock=stock-(:new.cantvendida) -- actualizar la tabla vestuario modificando el stock, lo va a llamar (resta o puede ser suma) resta (:new.cantvendida) => Eso es la cantidad vendida de la nueva venta. 
where codvest=(:new.codigovest); -- Donde codvest = (:new.codigovest) El nuevo codigo de la venta.
end;

insert into ventafinal values(sec_ven.nextval,'30/11/2021',6,'v2097');

select * from vestuario;

```

## Ejercicios

1)	Crear un procedimiento almacenado, sin parámetros, que permita:
a)	Insertar un vestuario (con un stock de 30).
b)	Vender 5 unidades de este vestuario insertado.
c)	Actualizar, en vestuario, el stock de esto vendido.


2)	Crear un procedimiento almacenado, sin parámetros, que permita mostrar los números de venta y las fechas, cuando las cantidades vendidas estén entre 4 y 8.


3)	Crear una función almacenada, sin parámetros, que permita mostrar la suma de cantidades vendidas.

4)	Crear un procedimiento almacenado, con parámetro, para que a los precios menores a un cierto valor indicado en el código le sume un valor enviado en la ejecución.


```sql

```
